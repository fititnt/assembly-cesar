
	ORG	0

	MOV	#Stack,R6

	; Teste com valor positivo
	MOV	#1200,-(R6)		; n
	MOV	#String,-(R6)	; s
	JSR	R7,uint2str
	ADD	#4,R6

	; Teste com valor negativo
	;MOV	#-1200,-(R6)	; n
	;MOV	#String,-(R6)	; s
	;JSR	R7,int2str
	;ADD	#4,R6

    MOV	#Stack2,R6
    MOV #Stack,R5
    MOV R5,R2
    JSR R7,_S_PREENCHE_VISOR
    MOV -(R5),R2
    JSR R7,_S_PREENCHE_VISOR
    MOV -(R5),R2
    JSR R7,_S_PREENCHE_VISOR
    MOV -(R5),R2
    JSR R7,_S_PREENCHE_VISOR
    MOV #'f',R2
    JSR R7,_S_PREENCHE_VISOR
	HLT


;>
;>
;> Subrotina para "preencher" o visor com um caractere
;>
;> Chamada da subrotina:
;>
;> MOV #codASCII,R2             ; colocar no R2 o caractere a ser usado
;> JSR R7,_S_PREENCHE_VISOR
;>

_S_PREENCHE_VISOR:
          MOV R0,-(R6)          ; salva R0 na pilha
          MOV R1,-(R6)          ; salva R1 na pilha
          MOV #65500,R1         ; move end. do visor p/R1
          MOV #36,R0            ; move 36 para contador
__MAIS1_LED:
          MOV R2,(R1)           ; move caractere p/1 LED do visor
          INC R1                ; aponta p/LED seguinte
          SOB R0,__MAIS1_LED    ; subtrai 1 do contador
                                ; se <> 0, repete o laco
          MOV (R6)+,R1          ; restaura R1
          MOV (R6)+,R0          ; restaura R0
          RTS R7                ; retorna ao ponto de chamada

;**********************************************************
; void int2str(char *s, uint n) {
;	2(R6) -> s -> R1
;	4(R6) -> n -> R2
;
;**********************************************************
int2str:
	MOV	2(R6),R1	; s
	MOV	4(R6),R2	; n

	BPL	EhPositivo	; 	if ( n < 0 ) {

	NEG	R2			; 		n = -n;

	MOV	-1(R1),R0	; 		*s++ = '-';
	AND	#HFF00,R0
	OR	#'-',R0
	MOV	R0,-1(R1)
	INC	R1
					; 	}

EhPositivo:
	MOV	R2,-(R6)	; 	uint2str(s,n);
	MOV	R1,-(R6)
	JSR	R7,uint2str
	ADD	#4,R6

	RTS	R7			; }


;**********************************************************
; void uint2str(char *s, uint n)
;	2(R6) -> s -> R1
;	4(R6) -> n -> R2
;
;	Lacos  -> R5
;	pTab10 -> R4
;	dig    -> R3
;
;**********************************************************
Tab10:		DAW	10000, 1000, 100, 10
uint2str:
	MOV	2(R6),R1	; R1 = s
	MOV	4(R6),R2	; R2 = n

	MOV	#Tab10,R4	; pTab10 = Tab10;
	MOV	#4,R5		; Lacos = 4;

Loop:				; do {
	MOV	#'0',R3		; 	dig = '0';

LoopInterno:
	CMP	R2,(R4)		; 	while (n >= *pTab10) {
	BLT	EhMenor
	INC	R3			; 		++dig;
	SUB	(R4),R2		; 		n -= *pTab10;
	JMP	LoopInterno	; 	}

EhMenor:
	MOV	-1(R1),R0	; 	*s++ = dig;
	AND	#HFF00,R0
	OR	R3,R0
	MOV	R0,-1(R1)
	INC	R1

	ADD	#2,R4		; 	++pTab10;

	SOB	R5,Loop		; } while (--Lacos);

	ADD	#'0',R2		; *s++ = n + ‘0’;
	MOV	-1(R1),R0
	AND	#HFF00,R0
	OR	R2,R0
	MOV	R0,-1(R1)
	INC	R1

	MOV	-1(R1),R0	; *s++ = '\0;
	AND	#HFF00,R0
	MOV	R0,-1(R1)

	RTS	R7


String:		DAB	'123456'

; Tamanho do stack de 1024 palavras
		DAW		[1024]
Stack:

; Tamanho do stack de 1024 palavras
		DAW		[1024]
Stack2:
